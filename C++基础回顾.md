# C++ 基础回顾
## C和C++区别
1. 一个面向对象，一个面向过程
2. C++中引入函数重载，引用，类
## static关键字
1. 修饰局部变量：在静态存储区分配内存，首次调用时进行初始化，之后不再进行初始化。
2. 修饰全局变量：在静态存储区分配内存，文件内可见，外部不可见。
3. 修饰函数时：文件内可见，外部不可见，避免多人协作，同名函数冲突
4. 修饰成员变量：所有对象公用一个，实现数据共享，不能在内部初始化，在类外部初始化
5. 修饰成员函数：不用实例化即可访问，不接受this，只能访问静态成员。
## define和const有什么区别
1. define是名称替换，不会分配内存;const是常量命名,会分配内存
## 静态链接库与动态链接库的区别
1.静态链接库是直接将代码拷贝到调用处，每个程序都会拷贝一份，删除实体文件不影响
2.动态链接库是运行时加载，多个程序用一个，由于运行时加载，影响前期性能
## 声明与定义
1. 声明不分配内存，只是说明该变量已经在别的文件定义了
2. 定义时会分配内存
## float ，指针与零值的比较
1.  -0.000001< float < 0.00000001
2. p == null 或 p!=null
## 智能指针有什么作用？分为哪几种？各自有什么样的特点？
1. auto_ptr: 同一时间只能有一个指针指向对象，已被C++11抛弃，对象转移时，如传参，所有权不会返还
2. unique_ptr: 同一时间只能有一个指针指向对象，无法进行拷贝构造但可以移动构造
3. shared_ptr: 共享拥有，可多个指针指向对象，自动释放资源
4. weak_ptr：解决shared_ptr相互引用死锁的问题。
## shared_ptr是如何实现的
1. 构造函数引用加1
2. 拷贝构造函数引用加1
3. 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1
4. 析构函数减1
5. 若减1后为0，则调用delete释放对象。
## 悬挂指针与野指针有什么区别？
1. 悬挂指针：对象释放后，指针指向为空
2. 野指针：指针未初始化
## 指针和引用的区别
1. 指针有自己的空间，引用是别称
2. 指针可以指向别的对象，引用只能是一个对象的引用
3. 指针和引用使用++运算符含义不一样
## 如何避免“野指针”
1. 初始化时赋值null
2. 释放资源时赋值null
## typedef 和 define 有什么区别
1. typedef是重命名，是编译过程部分，有作用域
2. define是宏定义，是预编译过程，不受作用域限制
## 简述#ifdef、#else、#endif和#ifndef的作用
1. 利用#ifdef、#endif将某程序功能模块包括进去，以向特定用户提供该功能。在不需要时用户可轻易将其屏蔽。
## 结构体可以直接赋值吗
1. 可以直接赋值
2. 若结构体相互赋值，其中含有指针成员时要注意，是浅拷贝。
## a和&a有什么区别？
假设数组int a[10]; int (*p)[10] = &a;
1. a是数组名
2. &a 是数组指针，p[0] 代表 a[0]指针的指针，*p[1]代表a[0]的指针， **p[1]代表a[0]。
## volatile有什么作用
volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题。
程序运行中，由于编译器优化，变量的值从缓存的地方读取，比如读取缓存在寄存器中的数值。
访问寄存器的速度要快过RAM，多任务环境中，变量可能被其他的程序（如中断程序、另外的线程等）所修改，
如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。
volatile应用场景：
1. 并行设备的硬件寄存器（如状态寄存器）
2. 一个中断服务子程序中访问到的变量；
3. 多线程应用中被多个任务共享的变量。
## sizeof 和 strlen 的区别
1. strlen是对字符串
2. sizeof是对整形或数组，并且sizeof计算的是数据类型占内存的大小
## 简述strcpy、sprintf 与memcpy 的区别
1. strcpy字符串
2. memcpy拷贝内存
3. sprintf是其他类型到字符转的转化
## 结构体和类的区别
1. 类有成员函数
2. 类有访问限定符
3. 类有继承关系
## 全局变量和局部变量有什么区别？操作系统和编译器是怎么知道的？
1. 全局变量生命周期随程序运行结束而消亡，局部变量随函数结束而结束
2. 全局变量是整个程序都可访问的变量
3. 全局变量分配在全局数据段并且在程序开始运行的时候被加载.局部变量则分配在堆栈里面。
## 右值引用有什么作用？
右值引用的主要目的是为了实现转移语义和完美转发。
1. 转移语义（参考[代码示例](https://blog.csdn.net/weixin_43718250/article/details/103464678)）
    + 转移和拷贝语义是相对的，可类比文件的剪切与拷贝，剪切比拷贝要快很多。
    + 有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率
2. 完美转发（参考[示例代码](https://blog.csdn.net/gaoZhuanMing/article/details/120247507)）
    + 在函数模板编程中，常在一个函数中引用另一个函数，若只提供值传递，效率低。
    + 所以常使用引用传参，可以避免对象拷贝，进而提高编程效率
    + 为了使一个函数既可以接受左值，又可以接受右值，C++11 之前的解决方案是将参数类型设为 const Type&. 但这并不是很方便，如限制了参数是常量.
    + 完美转发即实现如果 arg 是一个右值引用，则转发之后结果仍是右值引用；反之，如果 arg 是一个左值引用，则转发之后结果仍是左值引用.
## 对于一个频繁使用的短小函数，应该使用什么来实现？有什么优缺点？
